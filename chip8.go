package gochip8

import (
	"errors"
)

var font_set = []uint8{
	0xF0, 0x90, 0x90, 0x90, 0xF0, // 0
	0x20, 0x60, 0x20, 0x20, 0x70, // 1
	0xF0, 0x10, 0xF0, 0x80, 0xF0, // 2
	0xF0, 0x10, 0xF0, 0x10, 0xF0, // 3
	0x90, 0x90, 0xF0, 0x10, 0x10, // 4
	0xF0, 0x80, 0xF0, 0x10, 0xF0, // 5
	0xF0, 0x80, 0xF0, 0x90, 0xF0, // 6
	0xF0, 0x10, 0x20, 0x40, 0x40, // 7
	0xF0, 0x90, 0xF0, 0x90, 0xF0, // 8
	0xF0, 0x90, 0xF0, 0x10, 0xF0, // 9
	0xF0, 0x90, 0xF0, 0x90, 0x90, // A
	0xE0, 0x90, 0xE0, 0x90, 0xE0, // B
	0xF0, 0x80, 0x80, 0x80, 0xF0, // C
	0xE0, 0x90, 0x90, 0x90, 0xE0, // D
	0xF0, 0x80, 0xF0, 0x80, 0xF0, // E
	0xF0, 0x80, 0xF0, 0x80, 0x80, // F
}

type stack []uint16

func (s stack) Push(v uint16) stack {
	return append(s, v)
}

func (s stack) Pop() (uint16, error) {
	l := len(s)
	if l == 0 {
		return 0, errors.New("Empty Stack")
	}

	result := s[l-1]
	s = s[:l-1]

	return result, nil
}

type Chip8 struct {
	memory      [4096]uint8   // 4kb of ram
	display     [64][32]uint8 //64 x 32 ram
	stack       [16]stack     //program stack
	delay_timer uint8
	sound_timer uint8

	vx         [16]uint8 //cpu v registers
	curr_input uint8
	pc         uint16 // program counter, points to current instruction in memory
	i_reg      uint16 // indexes memory

}

func Init() Chip8 {
	emu := Chip8{
		pc: 0x200,
	}

	for i := 0; i < len(font_set); i++ {
		emu.memory[i] = font_set[i]
	}

	return emu

}
